-- Payload: KillSystem (this file is what's reinjected after teleport)
-- NOTE: This file should be saved as plain Lua at the raw URL used by the loader.

-- One-time guard (per JobId)
if _G.KillSystemActive and _G.KillSystemActiveJobId == game.JobId then
    warn("ðŸš« Kill system already active in this server")
    return
end
_G.KillSystemActive = true
_G.KillSystemActiveJobId = game.JobId

if not game:IsLoaded() then game.Loaded:Wait() end

local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local TeleportService = game:GetService("TeleportService")

local LPlayer = Players.LocalPlayer
local Remotes = ReplicatedStorage:WaitForChild("Remotes")
local StampAsset = Remotes:WaitForChild("StampAsset")
local LPlate

-- Find local plate
do
    local Plates = Workspace:FindFirstChild("Plates") or Workspace:WaitForChild("Plates", 2)
    if Plates then
        for _, plate in ipairs(Plates:GetChildren()) do
            local owner = plate:FindFirstChild("Owner")
            local ppart = plate:FindFirstChild("Plate")
            if owner and ppart and owner.Value == LPlayer then
                LPlate = ppart
                break
            end
        end
    end
end

local KillModule = {}

local function resolveTarget(target)
    if typeof(target) == "Instance" then
        if target:IsA("Player") then
            local char = target.Character or target.CharacterAdded:Wait()
            return char:WaitForChild("HumanoidRootPart", 5)
        elseif target:IsA("BasePart") then
            return target
        end
    end
end

local function invokeStamp(parts, cframe)
    if not parts or not StampAsset then return end
    local ok, res = pcall(function()
        return StampAsset:InvokeServer(41324885, cframe, "{}", parts, 0)
    end)
    if not ok then warn("[StampAsset Failed]:", res) end
    return res
end

function KillModule.Kill(target, cframeOverride)
    local part = resolveTarget(target)
    if part and LPlate then
        local dest = cframeOverride or (LPlate.CFrame - Vector3.new(0, 9e9, 0))
        return invokeStamp({ part }, dest)
    end
end

function KillModule.KillMany(targets, cframeOverride)
    local parts = {}
    for _, t in ipairs(targets) do
        local p = resolveTarget(t)
        if p then parts[#parts+1] = p end
    end
    if #parts > 0 and LPlate then
        local dest = cframeOverride or (LPlate.CFrame - Vector3.new(0, 9e9, 0))
        return invokeStamp(parts, dest)
    end
end

function KillModule.AttachAll(interval)
    interval = interval or 0.1
    task.spawn(function()
        while task.wait(interval) do
            for _, p in ipairs(Players:GetPlayers()) do
                if p ~= LPlayer and not LPlayer:IsFriendsWith(p.UserId) then
                    local part = resolveTarget(p)
                    if part and LPlate then
                        invokeStamp({ part }, LPlate.CFrame)
                    end
                end
            end
        end
    end)
end

-- Auto monitor respawns
local function monitorPlayer(player)
    if player ~= LPlayer and not LPlayer:IsFriendsWith(player.UserId) then
        player.CharacterAdded:Connect(function(character)
            local hrp = character:WaitForChild("HumanoidRootPart")
            KillModule.Kill(hrp)
        end)
    end
end

Players.PlayerAdded:Connect(monitorPlayer)
for _, p in ipairs(Players:GetPlayers()) do
    monitorPlayer(p)
end

KillModule.AttachAll(0.1)

-- Camera crash guard
local function safeCameraFix()
    local cam = Workspace.CurrentCamera
    if cam and typeof(cam.CameraType) == "EnumItem" then
        cam.CameraType = Enum.CameraType.Custom
    end
end
task.defer(function() task.wait(0.1); safeCameraFix() end)
Workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
    task.wait(0.1)
    safeCameraFix()
end)

print("[PAYLOAD] Reinjected successfully")
